#!/usr/bin/env python3

import collections
import datetime
import fractions
import json

from plot import MIN_POSITIVE_COUNT

# This doesn't actually do much, it just helps us center on the dynamic range of the Javascript float.
# sqrt(max(pin_count_list)) should be a good guess.
PIN_CUMULATIVES_SCALE = 10_000


HTML_HEADER = """
<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="stylesheet" href="x/style.css">
  <title>PIN analysis and visualization in HIBP</title>
  <meta name="description" content="PIN analysis and visualization in HIBP" />
  <link rel="canonical" href="https://benwiederhake.github.io/newpinvis/" />
  <meta property="og:url" content="https://benwiederhake.github.io/newpinvis/" />
  <meta property="og:site_name" content="BenWiederhake.github.io/newpinvis/" />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary" />
  <meta property="twitter:title" content="PIN analysis and visualization in HIBP" />
  <script type="application/ld+json">
  {"@context":"https://schema.org","@type":"WebSite","description":"PIN analysis and visualization in HIBP","headline":"PIN analysis and visualization in HIBP","name":"BenWiederhake.github.io","url":"https://benwiederhake.github.io/newpinvis/"}</script>
</head>
<body>
  <div id="container">
    <div class="inner">
      <header>
        <h1>PIN analysis and visualization in HIBP</h1>
        <h2>Automated analysis of the current “favorite” PINs, and a secure generator</h2>
      </header>
      <hr>
      <section id="main_content">
<h2>Results</h2>

<p>This page was last re-built on MAGIC_LAST_BUILT.</p>

<h3 id="gen-pin">Freshly generated, “secure” PINs</h3>

<p>Here are ten PINs, freshly generated by your browser: <span id="generated_pins">LOADING</span></p>

<p>Don't like these numbers? <a onclick="reroll()" href="#gen-pin">Click here to re-roll</a> instead of modifying the numbers yourself!</p>

<p>Of course, <em>ideally</em> you shouldn't trust some random guy on the internet to provide you with a “secure” PIN. Instead, you should either let your bank generate PINs for you, or write a PIN generator yourself, or even roll 4 ten-sided dice. I won't take any responsibility if you use any of the above PINs, and something bad happens to your account/money/pet. Please use common sense. And for the love of god, don't use <code>1234</code> as a PIN, or any other very popular PIN!</p>

<h3>Top 10 PINs</h3>

<p>The most popular are (most to less popular): MAGIC_TOP_TEN</p>
<p>If you use any of these PINs for anything that needs to the slightest bit of security, please do yourself a favor and change it immediately.</p>

<h3>Interactive PIN map</h3>

<div class="imagemap">
<img class="imagemap-map" src="plot.png" width="1000" >
"""

HTML_FOOTER = """
</div>
<svg style="display: none"><symbol id="r" viewBox="-1 -1 11 11"><style>
  symbol:hover { opacity: 1.0; }
  symbol {
    opacity: 0;
    stroke: #dff;
    stroke-width: 2px;
    fill: rgba(0, 0, 0, 0);
    transition: all 0.15s;
  }
</style><rect x="-1" y="-1" width="11" height="11"></rect></symbol></svg>

<h3>General observations</h3>
<ul>
  <li>Yes, 1234 is still a terrible PIN, just like other “obvious” progressions, quadruple-digits, or anything that could be a MMDD, DDMM, or YYYY date.</li>
  <li>I'm especially disappointed in the continued trend of birthyears being used.</li>
  <li>69/420/666 is still reasonably popular, but lucky number 7 seems to have fallen out of fashion.</li>
  <li>The “telephone layout” (PINs 2580 and 0852; MAGIC_TELEPHONE_USES uses) is still more popular than the “numpad layout” (PINs 8520 and 0258; MAGIC_NUMPAD_USES uses). This seems to confirm datagenetics' finding that these PINs might indeed be used for more serious things (e.g. banking contexts).</li>
</ul>

<h3>Download</h3>

<ul>
  <li><a href="table.json">Download <code>table.json</code></a>: Maps each PIN to its SHA1 hash, which makes it easier to look it up on HIBP.</li>
  <li><a href="list.json">Download <code>list.json</code></a>: A list that contains 10000 numbers, each indicating how often each PIN was found in the HIBP dataset. You could use that file to make your own interactive graphic, or PIN generator.</li>
  <li><a href="probabilities.json">Download <code>probabilities.json</code></a>: A comparison how well each PIN generation approach fares against each possible attacker.</li>
</ul>

<h2>Background</h2>

<h3>Inspiration</h3>

<p>I recently read a nice blog post by <a href="http://datagenetics.com/blog/september32012/index.html">datagenetics.com (Nick Berry?)</a>, from about September 2012. It tells the story of how password leaks happen, that they contain PINs, and lots of interesting analysis on them.</p>
<p>However, a long time has passed since September 2012, and in the end I had several questions:</p>
<ul>
  <li>Is 1234 still the most popular password?</li>
  <li>The birthyears were very well visible in his dump – they should have shifted by now, right?</li>
  <li>What's that spot? And that other spot? Can't you make an interactive version please, where it shows you the number when you hover with the mouse or something?</li>
  <li>And where's the machine-readable data?</li>
  <li>Is the "bank PIN" conclusion still applicable?</li>
  <li>This dataset would be a fantastic starting point to make a PIN recommendation generator! Where is it?</li>
  <li>Can you make it self-updating maybe?</li>
</ul>
<p>This page scrapes the data from <a href="https://haveibeenpwned.com/Passwords">Have I Been Pwned</a> and answers <em>all</em> of these questions! :)</p>

<h3>On PIN generation schemes</h3>

<p>At first glance, picking a PIN uniformly at random seems like the best approach: Each PIN would have exactly the same probability, meaning the probability that an attacker can successfully guess your PIN is as low as possible.</p>
<p>However, we already know that the attacker is very likely going to prioritize certain numbers over other numbers. In particular, we can reasonably expect that the attacker will use one of the following approaches, or a combination thereof:</p>

<ul>
  <li>The attacker might simply try the three most popular PINs. If the attacker has three tries, this would have a success rate of MAGIC_TOP_THREE_RATE when used on the general population! A frightening reminder not to use those PINs for any of your bank cards. Let's call this approach <code>top3</code>.</li>
  <li>Or perhaps the attacker is just trying out truly uniformly random PINs. Let's call this approach <code>uni</code>.</li>
  <li>Perhaps the attacker computed similar statistics as this blog post, and randomly tries PINs, weighted accordingly. Let's assume that the attacker observes similar numbers – this is easily justified because I got basically the same numbers as a blog post from 2012. Let's call this approach <code>real</code>.</li>
  <li>Perhaps the attacker has read this blog post, and randomly tries PINs with the same weighting as the above PIN generator. This is somewhat unlikely, but it's a good sanity check to see if the “secure” PIN generator accidentally makes things less secure. Let's call this approach <code>invreal</code>. (Spoiler: Yes, of course it is less secure than “uniform random” according to some metrics; however, it is more secure in other metrics. Deciding which ones to use is the the whole point of this subsection.)</li>
</ul>

<p>The following table compares the chances of success given each pairing of PIN generation and attacker. The variant <code>top1</code> always guesses <code>1111</code>, and <code>top10</code> always guesses the top ten most popular PINs, weighted according to real-life use. Note that PIN generator and attacker are interchangable, so pick your favorite interpretation of the axes:</p>

<table>
MAGIC_COMPARISON_TABLE
</table>

<p>Keep in mind that there are 10000 possible PINs, so a result of 0.010% is perfect, and something slightly worse (perhaps up to 0.050%) could be considered acceptable in many situations. Note that even if the attacker <em>knows</em> that you are using this approach, this only means that he can raise his chances from 0.010% to <span id="highest_invreal_prob">COMPUTING</span>, a miniscule step.</p>

<p>Anyway, I hope you see this as strong evidence the <code>invreal</code> method is reasonably good. Again, I don't take responsibility if something goes wrong due to this, but I think this approach is much better than using the brain's random-number generator, and probably quite a bit better than using uniformly-random PINs.</p>

<footer>
  <p>
    Feel free to re-use this page as you see fit; it is licensed under the <a href="LICENSE">“Unlicense”</a> to the extent I have the power to decide.
    This project strives to be <a href="https://haveibeenpwned.com/API/v3#AcceptableUse">awesome</a> as per the HIBP Acceptable Use Policy.
    This project is based entirely on data from the HIBP, which is licensed under the
    <a href="https://haveibeenpwned.com/API/v3#License">Creative Commons Attribution 4.0 International License</a>.
  </p>
  <p>
    The code for this project can be found in this repository: <a href="https://github.com/BenWiederhake/newpinvis/">https://github.com/BenWiederhake/newpinvis/</a>
  </p>
  <p>
    Live a good life, be kind, improve humanity.
  </p>
</footer>
</section>
</div>
</div>
<script src="app.js"></script>
</body>
"""

JS_CODE = """
"use strict";

const PIN_MAX = MAGIC_PIN_MAX;
const PIN_CUMULATIVES = [MAGIC_PIN_CUMULATIVES];
function randomPin() {
  let random_offset = PIN_MAX * Math.random();
  for (var i = 0; i < PIN_CUMULATIVES.length; ++i) {
    if (PIN_CUMULATIVES[i] > random_offset) {
      return String(i).padStart(4, "0");
    }
  }
  return "????"; // Should never happen!
}

function reroll() {
  var ten_pins = "";
  for (var i = 0; i < 10; ++i) {
    if (i != 0) {
      ten_pins += ", ";
    }
    ten_pins += `<code>${randomPin()}</code>`;
  }

  document.getElementById("generated_pins").innerHTML = ten_pins;
}

function reportHighestInvrealProb() {
  var last_accu = 0.0;
  var highest_step = 0.0;
  for (var i = 0; i < PIN_CUMULATIVES.length; ++i) {
    let this_step = PIN_CUMULATIVES[i] - last_accu;
    if (this_step > highest_step) {
      highest_step = this_step;
    }
    last_accu = PIN_CUMULATIVES[i];
  }
  let worstcase_percentage = 100 * highest_step / PIN_MAX;
  document.getElementById("highest_invreal_prob").textContent = `${worstcase_percentage.toFixed(3)}%`;
}

reroll();
reportHighestInvrealProb();
"""


def generate_header(pin_count_list):
    header = HTML_HEADER

    # "Falsehoods programmers believe: Just using UTC everywhere will surely fix everything"
    now = datetime.datetime.now(datetime.UTC).strftime("%Y-%m-%d %H:%M:%S %Z")
    assert "MAGIC_LAST_BUILT" in header
    header = header.replace("MAGIC_LAST_BUILT", now)

    top10_items = sorted(enumerate(pin_count_list), key=lambda e: e[1])[:-11:-1]
    top10_pins = [f"{pin:04}" for pin, _ in top10_items]
    assert "MAGIC_TOP_TEN" in header
    header = header.replace("MAGIC_TOP_TEN", ", ".join(top10_pins))

    yield header


def generate_footer(pin_count_list, probs):
    footer = HTML_FOOTER

    telephone_uses = f"{pin_count_list[2580]}+{pin_count_list[852]}={pin_count_list[2580] + pin_count_list[852]}"
    assert "MAGIC_TELEPHONE_USES" in footer
    footer = footer.replace("MAGIC_TELEPHONE_USES", telephone_uses)

    numpad_uses = f"{pin_count_list[8520]}+{pin_count_list[258]}={pin_count_list[8520] + pin_count_list[258]}"
    assert "MAGIC_NUMPAD_USES" in footer
    footer = footer.replace("MAGIC_NUMPAD_USES", numpad_uses)

    top3_items = sorted(enumerate(pin_count_list), key=lambda e: e[1])[:-4:-1]
    top3_counts = [count for _, count in top3_items]
    total_count = sum(pin_count_list)
    top3_calc = f"({top3_counts[0]}+{top3_counts[1]}+{top3_counts[2]})/{total_count}"
    top3_result = f"{sum(top3_counts) / total_count * 100:.1f}%"
    assert "MAGIC_TOP_THREE_RATE" in footer
    footer = footer.replace("MAGIC_TOP_THREE_RATE", f"{top3_calc} = {top3_result}")

    comparison_table_parts = []
    comparison_table_parts.append("<tr><td></td>")
    handles = [handle for handle, _ in probs["desc"]]
    for handle_col in handles:
        comparison_table_parts.append(f"<th><code>{handle_col}</code></th>")
    comparison_table_parts.append("</tr>\n")
    for handle_row in handles:
        comparison_table_parts.append(f"<tr><th><code>{handle_row}</code></th>")
        handles = [handle for handle, _ in probs["desc"]]
        for handle_col in handles:
            corr = probs["corrs"][handle_col][handle_row]
            comparison_table_parts.append(f"<td>{corr * 100:.3f}%</td>")
        comparison_table_parts.append("</tr>\n")
    assert "MAGIC_COMPARISON_TABLE" in footer
    footer = footer.replace("MAGIC_COMPARISON_TABLE", "".join(comparison_table_parts))

    yield footer


def generate_html(pin_count_list, probs):
    yield from generate_header(pin_count_list)

    total_count = sum(pin_count_list)
    for lhs in range(100):
        for rhs in range(100):
            x = rhs
            y = 99 - lhs
            css_class = "zmp" if x < 50 else "zmq"
            pin = lhs * 100 + rhs
            pin_str = f"{pin:04}"
            rate = pin_count_list[pin] / total_count
            assert 0.0 <= rate < 1.0, (pin, rate)
            # At the time of writing, there's about 29 million recorded PINs in the dataset.
            # Let's assume we don't care if <500 gets rounded to zero (also, these data points seem to be missing / set to zero).
            # That would be 500/29e6*100 = 0.00172 %, so 4 decimal digits is enough.
            rate_str = f"{100 * rate:.4f}%"
            # FIXME: This is slow as hell! Do this in Javascript on-the-fly instead.
            yield f'<div class="{css_class}"style="left:{x}%;top:{y}%"><svg><use href="#r"></use></svg><div>{pin_str} ({rate_str})</div></div>'
            # Examples with nonsensical numbers:
            # <div class="zmp"style="left:10%;top:5%"><svg><use href="#r"></use></svg><div>2345 (0.83%)</div></div>
            # <div class="zmq"style="left:11%;top:4%"><svg><use href="#r"></use></svg><div>3456 (1.94%)</div></div>

    yield from generate_footer(pin_count_list, probs)


def generate_pin_cumulatives(pin_count_list, max_cumulative_container):
    accu = fractions.Fraction()
    for count in pin_count_list:
        accu += fractions.Fraction(PIN_CUMULATIVES_SCALE, max(count, MIN_POSITIVE_COUNT))
        yield str(float(accu))
    # Can't easily use 'return' here, so we abuse the passed-in list to pass a "return" value:
    max_cumulative_container.append(str(float(accu)))


def compute_js(pin_count_list):
    js_code = JS_CODE

    max_cumulative_container = []
    pin_cumulatives = ",".join(generate_pin_cumulatives(pin_count_list, max_cumulative_container))

    assert "MAGIC_PIN_CUMULATIVES" in js_code
    js_code = js_code.replace("MAGIC_PIN_CUMULATIVES", pin_cumulatives)
    assert "MAGIC_PIN_MAX" in js_code
    js_code = js_code.replace("MAGIC_PIN_MAX", max_cumulative_container[0])
    return js_code


def run():
    with open("target/list.json", "r") as fp:
        pin_count_list = json.load(fp)
    with open("target/probabilities.json", "r") as fp:
        probs = json.load(fp)
    assert probs["type"] == "newpinvis_reluctantwhistleravioli_probs_v1"

    html = "".join(generate_html(pin_count_list, probs))
    #js = generate_js(pin_count_list)
    with open("target/index.html", "w") as fp:
        fp.write(html)
    with open("target/app.js", "w") as fp:
        fp.write(compute_js(pin_count_list))


if __name__ == "__main__":
    run()
